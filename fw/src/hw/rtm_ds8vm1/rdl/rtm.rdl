`include "rtm.vh"

// default defines if not defined in rtm.vh
`ifndef C_ID
`define C_ID 0x000d5801
`endif
`ifndef C_VERSION
`define C_VERSION 0x00000000
`endif

// address map
addrmap rtm {
  name="DRTM-DS8VM1";
  desc = "RTM DS8VM1 module";
  desyrdl_interface = "AXI4L";

  reg {
    desc="Module Identification Number";
    default sw = r;
    default hw = r;
    field {} data[32] = `C_ID;
  } ID @0x00;

  reg {
    desc="Module Version Number";
    default sw = r;
    default hw = r;
    field {} changes [8] =  `C_VERSION & 0x000000FF;
    field {} patch [8]   = (`C_VERSION & 0x0000FF00) >> 8;
    field {} minor [8]   = (`C_VERSION & 0x00FF0000) >> 16;
    field {} major [8]   = (`C_VERSION & 0xFF000000) >> 24;
  } VERSION @0x04;


  reg {
  desc="Further Identification/Name of the RTM";
  default sw = r;
  default hw = rw;
  field {} data[32];
  } NAME[2];

  reg {
  desc = "Handles interlock on the RTM side. Connected to RF gate. Value:[br]
  0 - Block drive (RF gate open)[br]
  1 - Drive will be allowed (RF gate closed)";
  default sw = rw;
  default hw = r;
  desyrdl_data_type = "uint";
  field {} data[1];
} RF_PERMIT;

reg {
  desc = "Select attenuator to be set by ATT_VAL register. 1 bit per attenuator.[br]
  bit[0:7]: attenuator on ADC channel 0 to 7[br]
  bit[8]: vector modulator output attenuator.[br]
  e.g. to selct attenuators on ch 1 and 5 set value = 2^1 + 2^5 = 34";
  default sw = rw;
  default hw = r;
  desyrdl_data_type = "uint";
  field {} data[9];
} ATT_SEL;

reg {
  desc = "Attenuator value to set for HMC624LP4 chip.[br]
  Atteunation = (63 - value) / 2 dBm. [br]
  Min attenuation 0 dBm: value = 63, max attenuation 31.5 dBm: value = 0 .";
  default sw = rw;
  default hw = r;
  default swmod;
  desyrdl_data_type = "uint";
  field {} data[6];
} ATT_VAL;

reg {
  desc = "Shows if there is I2C Communication with any attenuators. When it is 1 there is an on-going i2c transaction. Wait until 0 before issuing ATT_VAL change.";
  default sw = r;
  default hw = w;
  desyrdl_data_type = "uint";
  field {} data[1];
} ATT_BUSY;

reg {
  desc = "Reference Power Measurement";
  default sw = r;
  default hw = w;
  default swacc;
  desyrdl_data_type = "int";
  field {} data[25];
} REF_POWER;

reg {
  desc = "LO Power Detector AD8363 Temperature digitized by LTC2493 ADC (I2C Address: 0x43). RAW ADC value.";
  default sw = r;
  default hw = w;
  default swacc;
  desyrdl_data_type = "int";
  field {} data[25];
} REF_TEMP;

reg {
  desc = "Shows if there is I2C Communication with LTC2493 ADC which samples the Reference line. When it is 1 on one of 1 bit there is an on-going i2c transaction.";
  default sw = r;
  default hw = w;
  desyrdl_data_type = "uint" ;
  field {} data[4];
} REF_ADC_BUSY;

reg {
  desc = "In-Phase common-mode voltage generated by LTC2697 for the Vector Modulator";
  default sw = rw;
  default hw = r;
  default swmod;
  desyrdl_data_type = "uint" ;
  field {} data[16];
} DAC_VM_COM_MODE_I;

reg {
  desc = "In-Phase common-mode voltage generated by LTC2697 for the Vector Modulator";
  default sw = rw;
  default hw = r;
  default swmod;
  desyrdl_data_type = "uint" ;
  field {} data[16];
} DAC_VM_COM_MODE_Q;

reg {
  desc = "Shows if LTC2607 is busy with I2C transaction. First bit is for VM_COM_MODE_Q, Second bit is for VM_COM_MODE_I";
  default sw = r;
  default hw = rw;
  desyrdl_data_type = "uint";
  field {} data[2] ;
} DAC_VM_BUSY;

reg {
  desc = "LMK04906 PLL for the Clock generation/distribution";
  default sw = rw;
  default hw = r;
  default swmod;
  desyrdl_data_type = "uint";
  field {} data[32];
} PLL_DATA;

reg {
  desc = "Shows if LMK04906 PLL is busy with I2C Transaction";
  default sw = r;
  default hw = w;
  desyrdl_data_type = "uint";
  field {} data[32];
} PLL_BUSY;

reg {
  desc = "Choose Single PLL (internal or external VCO) or double PLL configuration for the LMK04906. Should be set to 1 for internal VCO
  This feature is only available board rev 1.2 and down. v.1.3 does not have it";
  default sw = rw;
  default hw = r;
  default swmod;
  desyrdl_data_type = "uint";
  field {} data[1];
} PLL_OSC_SEL;

reg {
  desc = "Divide the Reference RF signal by an interger:
  b00 -> Divide by 1
  b01 -> Divide by 2
  b10 -> Divide by 3
  b11 -> Divide by 4";
  default sw = rw;
  default hw = r;
  default swmod;
  desyrdl_data_type = "uint";
  field {} data[2];
} REFERENCE_DIV;

reg {
  desc = "Choose clock source for the PLL input. Should be set to 1 for Front panel CLK selection. Warning: This feature is only available on board revision 1.2 and down. v.1.3 does not have it";
  default sw = rw;
  default hw = r;
  default swmod;
  desyrdl_data_type = "uint";
  field {} data[1];
} PLL_CLK_IN_SEL;

reg {
  desc = "Provides various monitoring signals on RTM
  [0] => PLL Lock Detection
  [1] => PLL Holdover Active
  [2] => PLL CLKin1 Loss of Signal
  [3] => PLL CLKin0 (TCLKA) Loss of Signal 
  [4] => Unused 
  [5] => VM Gate Monitor 1-> RF is allowed 0-> RF NOT Allowed 
  [6] => AMC Interlock Monitor 0-> AMC is letting drive 1-> AMC is not letting drive 
  [7] => Unused";
  default sw = r;
  default hw = w;
  default swacc;
  desyrdl_data_type = "uint";
  field {} data[8];
} RTM_STATUS;

reg {
  desc = "Temperature reading from on-board thermistor digitized by an ADC (Ch0 minus Ch1 value)
I2C address of the ADC: 16h (Care! On schematics it is written wrong).";
  default sw = r;
  default hw = w;
  default swacc;
  desyrdl_data_type = "int";
  field {} data[25];
} TEMP_A;

reg {
  desc = "Temperature reading from on-board thermistor digitized by an ADC (Ch2 minus Ch3 value)
I2C address of the ADC: 16h (Care! On schematics it is written wrong).";
  default sw = r;
  default hw = w;
  default swacc;
  desyrdl_data_type = "int";
  field {} data[25];
} TEMP_B;

reg {
  desc = "Temperature reading from on-board thermistor digitized by an ADC (Ch2 minus Ch3 value)
I2C address of the ADC: 16h (Care! On schematics it is written wrong).";
  default sw = r;
  default hw = w;
  default swacc;
  desyrdl_data_type = "int";
  field {} data[12];
} TEMP_C;

reg {
  desc = "Temperature reading from on-board 12-bit Temperature Sensor (MAX6626) +
I2C address: 49h.";
  default sw = r;
  default hw = w;
  default swacc;
  desyrdl_data_type = "int";
  field {} data[12];
} TEMP_D;

reg {
  desc = "Temperature reading from on-board 12-bit Temperature Sensor (MAX6626) +
I2C address: 4Ah";
  default sw = r;
  default hw = w;
  default swacc;
  desyrdl_data_type = "int";
  field {} data[12];
} TEMP_E;

reg {
  desc = "Temperature reading from on-board 12-bit Temperature Sensor (MAX6626) +
I2C address: 4Bh";
  default sw = r;
  default hw = w;
  default swacc;
  desyrdl_data_type = "int";
  field {} data[12];
} TEMP_F;

reg {
  desc = "Monitoring the External Interlock coming from the Front Panel of the RTM
  If it is 1 that means interlock is preventing the drive
  If it is 0 that means drive is permitted";
  default sw = r;
  default hw = w;
  desyrdl_data_type = "uint";
  field {} data[1];
} EXT_INTERLOCK;

reg {
  desc = "Select reset type for the PLL and the Reference Divider (Synch or Async)
  0 => Selection from WORD_CLK_RST_SOURCE(Synched with TCLK from Backplane)
  1 => Selection from WORD_CLK_RST_SOURCE (Async)";
  default sw = rw;
  default hw = r;
  default swmod;
  desyrdl_data_type = "uint";
  field {} data[1];
} CLK_RST_SELECT;

reg {
  desc = "Select Reset Source
  0 => AMC Reset from Z3 
  1 => Reset Input from Front Panel of DS8VM1";
  default sw = rw;
  default hw = r;
  default swmod;
  desyrdl_data_type = "uint";
  field {} data[1];
} CLK_RST_SOURCE;

reg {
  desc = "Choose a clock input for the sync clock reset path (?)";
  default sw = rw;
  default hw = r;
  default swmod;
  desyrdl_data_type = "uint";
  field {} data[1];
} SYNC_CLK_SELECT;

reg {
  desc = "Choose a clock input for the sync clock reset path (?)";
  default sw = rw;
  default hw = r;
  default swmod;
  desyrdl_data_type = "uint";
  field {} data[1];
} CLK_RST_ENABLE;

};
